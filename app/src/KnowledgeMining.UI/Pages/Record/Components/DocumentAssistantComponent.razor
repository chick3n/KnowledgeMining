@using KnowledgeMining.Domain.Entities
@using KnowledgeMining.UI.Models
@using System.Text.Json.Serialization
@using KnowledgeMining.UI.Services.Documents

@if(DocumentAssistantService?.IsEnabled ?? false) 
{
    <MudExpansionPanels>
        <MudExpansionPanel Text="@title"  
            IsInitiallyExpanded="CanAssit()" Disabled="!CanAssit()">
            <div>
                @foreach(var response in chat)
                {

                    if(response.Item1 == responseType.human)
                    {
                        <MudField Variant="Variant.Outlined"
                            Style="text-align:right"
                            >@response.Item2</MudField>
                    }
                    else
                    {
                        <MudField Variant="Variant.Outlined"
                            Style="background-color:#fafafa"
                            Label="Assistant"
                            >@response.Item2</MudField>
                    }

                
                }
                @if(waitingForResponse) {
                    <MudSkeleton SkeletonType="SkeletonType.Text" Height="40px" />
                }
            </div>

            <MudTextField  @bind-Value="Prompt" 
                Disabled="waitingForResponse"
                Variant="Variant.Text" 
                Adornment="Adornment.End" 
                AdornmentIcon="@Icons.Material.Filled.Chat" 
                OnKeyUp="PromptIfKeyPressed"
                AdornmentColor="Color.Secondary"
                OnAdornmentClick="PromptClicked" />
        </MudExpansionPanel>
    </MudExpansionPanels>

    <hr />
}

@code {
    [Parameter] public DocumentMetadata? Document { get; set; }
    [Inject]    public DocumentAssistantService? DocumentAssistantService { get; set; }

    private string[] restrictedDocumentTypes = new [] { "sitrep", "readouts", "multilateral forum statements", "reports and assessments" };

    public string? Prompt { get; set; }

    private enum responseType {
        ai,
        human
    };

    private List<Tuple<responseType, string>> chat = new();
    private bool waitingForResponse = false;
    private bool IsOnline = true;
    private string title = "Virtual Assistant";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await Startup();
        }
    }

    private bool CanAssit()
    {
        var documentType = Document?.GetValue("documentType") ?? "article";
        if (restrictedDocumentTypes.Contains(documentType.ToLower()))
            return false;


        return DocumentAssistantService != null && DocumentAssistantService.CanAssist() && IsOnline;
    }

    private async Task Startup()
    {
        if (!CanAssit())
            return;

        //check if assistant api is online
        waitingForResponse = true;
        IsOnline = await DocumentAssistantService!.IsOnline();

        if (!IsOnline) {
            AddResponseToChat(responseType.ai, GetOfflineResponse());
        }
        else
            AddResponseToChat(responseType.ai, GetIntroResponse());
    }

    private string GetIntroResponse()
    {
        var documentType = Document?.GetValue("documentType") ?? "article";
        if (documentType.Equals("News Media"))
            documentType = "news article";
        return $"What would you like to know about this {documentType.ToLower()}?";
    }

    private string GetOfflineResponse()
    {
        return $"I am currently offline.";
    }

    private async Task PromptClicked(MouseEventArgs args)
    {
        await PromptAssistantStart();
    }

    private async Task PromptIfKeyPressed(KeyboardEventArgs e)
    {
        if (e.Code == "Enter" || e.Code == "NumpadEnter")
        {
            await PromptAssistantStart();
        }
    }

    private async Task PromptAssistantStart()
    {
        if (string.IsNullOrWhiteSpace(Prompt))
            return;

        var query = Prompt.Trim();
        Prompt = "";
        chat.Add(new Tuple<responseType, string>(responseType.human, query));
        waitingForResponse = true;
        await PromptAssistant(query);
    }

    private void PromptAssistantGenericFailure()
    {
        AddResponseToChat(responseType.ai, "Something went wrong, refresh the page to try again.", false);
    }

    private async Task PromptAssistant(string query)
    {
        var invalid = string.IsNullOrWhiteSpace(query) || 
            Document == null || 
            string.IsNullOrEmpty(Document.Content) ||
            DocumentAssistantService == null;

        if(invalid)
        {
            PromptAssistantGenericFailure();
            return;
        }

        var response = await DocumentAssistantService!.SimplePrompt(query, Document!.Content!, Document.Name!);

        if(string.IsNullOrEmpty(response))
        {
            PromptAssistantGenericFailure();
            return;
        }

        AddResponseToChat(responseType.ai, response);
    }

    private void AddResponseToChat(responseType rtype, string message, bool acceptMoreResponses = true)
    {
        chat.Add(new Tuple<responseType, string>(rtype, message));
        waitingForResponse = !acceptMoreResponses;  
        StateHasChanged();
    }
}

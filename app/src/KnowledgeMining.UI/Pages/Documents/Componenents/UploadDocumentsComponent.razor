@using KnowledgeMining.UI.Pages.Documents.ViewModels
@inject ISnackbar Snackbar
@inject IMediator Mediator
@inject IStringLocalizer<SharedResources> Localizer

<MudDialog>
    <DialogContent>
    <div class="d-flex flex-column">
        <InputFile id="fileInput" OnChange="OnInputFileChanged" hidden multiple />
        <MudButton HtmlTag="label"
                   Variant="Variant.Filled"
                   Color="Color.Primary"
                   StartIcon="@Icons.Filled.CloudUpload"
                   Style="margin-bottom: 10px"
                   for="fileInput">
                @Localizer["home"]
            Add your documents
        </MudButton>
        <MudDivider Light="true" Style="margin-bottom: 10px" />
        <MudTable Items="_files" Height="@_tableHeight">
            <HeaderContent>
                    <MudTh>@Localizer["documentName"]</MudTh>
                    <MudTh>@Localizer["documentType"]</MudTh>
                <MudTh></MudTh>
            </HeaderContent>
            <RowTemplate>
                    <MudTd DataLabel=@Localizer["documentName"]>@context.File.Name</MudTd>
                    <MudTd DataLabel=@Localizer["documentType"]>
                        <MudSelect Required="true" T="string" Placeholder=@Localizer["selectDocumentType"]
                                   ValueChanged="@(e => ApplyTagToUploadFile(context.File.Name, "documenttype", e))">
                        @foreach (var allowedValue in DocumentTags.SelectMany(x => x.AllowedValues))
                        {
                            <MudSelectItem Value="@allowedValue" />
                        }
                    </MudSelect>
                </MudTd>
                <MudTd DataLabel="">
                        <MudIconButton Title=@Localizer["remove"] Icon="@Icons.Filled.RemoveCircleOutline" OnClick="@(_ => RemoveUploadFile(context))" />
                </MudTd>
            </RowTemplate>
        </MudTable>
    </div>
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="Upload"
                       Disabled="@(DisableUploadButton())"
                       Variant="Variant.Filled"
                       Color="Color.Primary"
                       StartIcon="@Icons.Filled.CloudUpload">
            @Localizer["upload"]
            </MudButton>
        <MudButton OnClick="Clear" Disabled="@(!_files.Any())" Color="Color.Error" Variant="Variant.Filled">@Localizer["clear1"]</MudButton>
            <MudSpacer />
        <MudButton OnClick="@Close" Color="Color.Error" Variant="Variant.Filled">@Localizer["close"]</MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter] MudDialogInstance MudDialog { get; set; }

    [Parameter]
    public EventCallback<IEnumerable<Application.Documents.Queries.GetDocuments.Document>> OnFilesUploaded { get; set; }

    public DocumentTag[]? DocumentTags { get; set; }

    private string _tableHeight = "";
    private bool _clearing = false;
    private IList<UploadDocumentViewModel> _files = new List<UploadDocumentViewModel>();
    private IDictionary<string, IDictionary<string, string>> _fileTags = new Dictionary<string, IDictionary<string, string>>();

    protected override async Task OnInitializedAsync()
    {
        DocumentTags = await Mediator.Send(new GetTagsQuery()) ?? Array.Empty<DocumentTag>();
    }

    public async Task Close()
    {
        await Clear();
        MudDialog.Cancel();
    }

    private bool DisableUploadButton()
    {
        if (_files.Count == 0)
            return true;

        if(_files.Any(x => string.IsNullOrEmpty(x.DocumentType)))
            return true;

        return false;
    }

    private void ApplyTagToUploadFile(string context, string tag, string value)
    {
        var file = _files.FirstOrDefault(x => x.File.Name.Equals(context));
        if(file != null)
        {
            switch(tag.ToLower())
            {
                case "documenttype": file.DocumentType = value;
                    break;
            }
        }
    }

    private void RemoveUploadFile(UploadDocumentViewModel file)
    {
        _files.Remove(file);
        AdjustTableHeight();
    }

    private IDictionary<string, string>? GetFileTags(UploadDocumentViewModel file)
    {
        return new Dictionary<string, string>()
        {
            { "documentType", file.DocumentType }
        };
    }

    private string GetFileTag(string fileName, string tag)
    {
        if (_fileTags.TryGetValue(fileName, out var tags))
        {
            (string tagName, string tagValue) = tags.Where(t => t.Key == tag).FirstOrDefault();

            return tagValue ?? string.Empty;
        }

        return string.Empty;
    }

    private void SetFileTag(string fileName, string tagName, string tagValue)
    {
        if (_fileTags.TryGetValue(fileName, out var tags))
        {
            if (tags.ContainsKey(tagName))
            {
                tags[tagName] = tagValue;
            }
            else
            {
                tags.Add(tagName, tagValue);
            }
        }
        else
        {
            _fileTags.Add(fileName, new Dictionary<string, string>());
        }
    }

    private void OnInputFileChanged(InputFileChangeEventArgs e)
    {
        foreach (var file in e.GetMultipleFiles())
        {
            if (_files.Any(x => x.File.Name.Equals(file.Name)))
                continue;
            _files.Add(new UploadDocumentViewModel
            {
                DocumentType = null,
                File = file
            });
        }
        AdjustTableHeight();
    }

    private void AdjustTableHeight()
    {        
        if(_files.Count > 5)
        {
            _tableHeight = "400px";
        }
        else
        {
            _tableHeight = "";
        }
    }

    private async Task Clear()
    {
        _clearing = true;
        _files.Clear();
        await Task.Delay(100);
        _clearing = false;
        AdjustTableHeight();
    }

    private async Task Upload()
    {
        IEnumerable<KnowledgeMining.Application.Documents.Queries.GetDocuments.Document> results = null;
        Snackbar.Configuration.PositionClass = Defaults.Classes.Position.TopCenter;

        try
        {
            var documentToUpload = 
                _files.Select(f => 
                    new Application.Documents.Commands.UploadDocument.Document(f.File.Name, 
                        f.File.ContentType, 
                        GetFileTags(f), 
                        f.File.OpenReadStream(maxAllowedSize: 10485760)));
            results = await Mediator.Send(new UploadDocumentCommand("documents", documentToUpload));

            var missingUploads = _files.Select(x => x.File.Name).Except(results.Select(x => x.Name));
            if (missingUploads.Count() > 0)
                Snackbar.Add($"Files {string.Join(",", missingUploads)} failed to upload.", Severity.Error);
            Snackbar.Add($"Files {string.Join(",", results.Select(x => x.Name))} uploaded successfully!", Severity.Success);
            await OnFilesUploaded.InvokeAsync(results);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to upload files! Reason: {ex.Message}", Severity.Error);
        }
        finally
        {
            await Clear();
            MudDialog.Close(DialogResult.Ok(results, typeof(IEnumerable<KnowledgeMining.Application.Documents.Queries.GetDocuments.Document>)));
        }
    }
}